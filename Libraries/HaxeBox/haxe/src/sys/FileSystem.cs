// Generated by Haxe 4.3.7 (patched: in-memory filesystem)

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace sys {
	public class FileSystem : global::haxe.lang.HxObject {
		
		public FileSystem(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public FileSystem() {
			global::sys.FileSystem.__hx_ctor_sys_FileSystem(this);
		}
		
		
		protected static void __hx_ctor_sys_FileSystem(global::sys.FileSystem __hx_this) {
		}
		
		
		private static object _lock = new object();
		
		private static global::System.Collections.Generic.Dictionary<string, byte[]> _files = new global::System.Collections.Generic.Dictionary<string, byte[]>();
		
		private static global::System.Collections.Generic.HashSet<string> _dirs = new global::System.Collections.Generic.HashSet<string>(new string[]{"/"});
		
		
		private static string NormalizePath(string path) {
			if (( path == null )) {
				return "";
			}
			
			string p = global::haxe.io.Path.normalize(path);
			if ( ! (global::haxe.io.Path.isAbsolute(p)) ) {
				p = global::haxe.io.Path.normalize(global::haxe.lang.Runtime.concat(global::Sys.getCwd(), p));
			}
			
			p = global::haxe.io.Path.removeTrailingSlashes(p);
			if (( p == "" )) {
				p = "/";
			}
			
			return p;
		}
		
		
		private static void EnsureDirInternal(string dir) {
			if (( dir == null )) {
				return;
			}
			
			string d = global::sys.FileSystem.NormalizePath(dir);
			if (( d == "/" )) {
				global::sys.FileSystem._dirs.Add("/");
				return;
			}
			
			int idx = global::haxe.lang.StringExt.lastIndexOf(d, "/", default(global::haxe.lang.Null<int>));
			if (( idx > 0 )) {
				string parent = global::haxe.lang.StringExt.substr(d, 0, new global::haxe.lang.Null<int>(idx, true));
				global::sys.FileSystem.EnsureDirInternal(parent);
			}
			
			global::sys.FileSystem._dirs.Add(d);
		}
		
		
		private static bool HasChild(string dir) {
			string prefix = ( ( dir == "/" ) ? ("/") : (global::haxe.lang.Runtime.concat(dir, "/")) );
			foreach (string key in global::sys.FileSystem._files.Keys) {
				if (global::StringTools.startsWith(key, prefix)) {
					return true;
				}
				
			}
			
			foreach (string key1 in global::sys.FileSystem._dirs) {
				if (global::StringTools.startsWith(key1, prefix)) {
					return true;
				}
				
			}
			
			return false;
		}
		
		
		internal static byte[] ReadFileBytes(string path) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				byte[] data = null;
				if (global::sys.FileSystem._files.TryGetValue(p, out data)) {
					return data;
				}
				
			}
			;
			return null;
		}
		
		
		internal static void WriteFileBytes(string path, byte[] bytes) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				int idx = global::haxe.lang.StringExt.lastIndexOf(p, "/", default(global::haxe.lang.Null<int>));
				if (( idx > 0 )) {
					global::sys.FileSystem.EnsureDirInternal(global::haxe.lang.StringExt.substr(p, 0, new global::haxe.lang.Null<int>(idx, true)));
				}
				else {
					global::sys.FileSystem.EnsureDirInternal("/");
				}
				
				global::sys.FileSystem._files[p] = bytes;
			}
			;
		}
		
		
		internal static void DeleteFileBytes(string path) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				if (global::sys.FileSystem._files.ContainsKey(p)) {
					global::sys.FileSystem._files.Remove(p);
				}
				
			}
			;
		}
		
		
		public static bool exists(string path) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				if (global::sys.FileSystem._files.ContainsKey(p)) {
					return true;
				}
				
				if (global::sys.FileSystem._dirs.Contains(p)) {
					return true;
				}
				
				return global::sys.FileSystem.HasChild(p);
			}
			
		}
		
		
		public static void rename(string path, string newPath) {
			string from = global::sys.FileSystem.NormalizePath(path);
			string to = global::sys.FileSystem.NormalizePath(newPath);
			lock(global::sys.FileSystem._lock){
				bool moved = false;
				if (global::sys.FileSystem._files.ContainsKey(from)) {
					byte[] data = global::sys.FileSystem._files[from];
					global::sys.FileSystem._files.Remove(from);
					global::sys.FileSystem._files[to] = data;
					moved = true;
				}
				
				global::System.Collections.Generic.List<string> dirMoves = new global::System.Collections.Generic.List<string>();
				foreach (string dir in global::sys.FileSystem._dirs) {
					if (( dir == from ) || global::StringTools.startsWith(dir, global::haxe.lang.Runtime.concat(from, "/"))) {
						dirMoves.Add(dir);
					}
					
				}
				
				foreach (string dir1 in dirMoves) {
					global::sys.FileSystem._dirs.Remove(dir1);
					string suffix = global::haxe.lang.StringExt.substr(dir1, from.Length, default(global::haxe.lang.Null<int>));
					global::sys.FileSystem._dirs.Add(global::haxe.lang.Runtime.concat(to, suffix));
					moved = true;
				}
				
				global::System.Collections.Generic.List<string> fileMoves = new global::System.Collections.Generic.List<string>();
				foreach (string key in global::sys.FileSystem._files.Keys) {
					if (global::StringTools.startsWith(key, global::haxe.lang.Runtime.concat(from, "/"))) {
						fileMoves.Add(key);
					}
					
				}
				
				foreach (string key1 in fileMoves) {
					byte[] data1 = global::sys.FileSystem._files[key1];
					global::sys.FileSystem._files.Remove(key1);
					string suffix1 = global::haxe.lang.StringExt.substr(key1, from.Length, default(global::haxe.lang.Null<int>));
					global::sys.FileSystem._files[global::haxe.lang.Runtime.concat(to, suffix1)] = data1;
					moved = true;
				}
				
				if ( ! (moved) ) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Path \'", path), "\' doesn\'t exist"))) );
				}
				
			}
			;
		}
		
		
		public static object stat(string path) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				if (global::sys.FileSystem._files.ContainsKey(p)) {
					byte[] data = global::sys.FileSystem._files[p];
					global::Date now = global::Date.now();
					int __temp_odecl1 = ((int) (( data as global::System.Array ).Length) );
					return new global::haxe.lang.DynamicObject(new int[]{262801146, 651890926, 1302870512}, new object[]{now, now, now}, new int[]{4995541, 5145602, 5246186, 5841808, 499574632, 1214305123, 1269206179, 1280549057}, new double[]{((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (__temp_odecl1) )});
				}
				
				if (global::sys.FileSystem._dirs.Contains(p) || global::sys.FileSystem.HasChild(p)) {
					global::Date now1 = global::Date.now();
					return new global::haxe.lang.DynamicObject(new int[]{262801146, 651890926, 1302870512}, new object[]{now1, now1, now1}, new int[]{4995541, 5145602, 5246186, 5841808, 499574632, 1214305123, 1269206179, 1280549057}, new double[]{((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) )});
				}
				
			}
			;
			throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Path \'", path), "\' doesn\'t exist"))) );
		}
		
		
		public static string fullPath(string relPath) {
			return global::sys.FileSystem.NormalizePath(relPath);
		}
		
		
		public static string absolutePath(string relPath) {
			if (global::haxe.io.Path.isAbsolute(relPath)) {
				return global::sys.FileSystem.NormalizePath(relPath);
			}
			
			return global::sys.FileSystem.NormalizePath(global::haxe.lang.Runtime.concat(global::Sys.getCwd(), relPath));
		}
		
		
		public static bool isDirectory(string path) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				bool isdir = global::sys.FileSystem._dirs.Contains(p) || global::sys.FileSystem.HasChild(p);
				if (( isdir != global::sys.FileSystem._files.ContainsKey(p) )) {
					return isdir;
				}
				
			}
			;
			throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Path \'", path), "\' doesn\'t exist"))) );
		}
		
		
		public static void createDirectory(string path) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				global::sys.FileSystem.EnsureDirInternal(p);
			}
			;
		}
		
		
		public static void deleteFile(string path) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				if ( ! (global::sys.FileSystem._files.ContainsKey(p)) ) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Path \'", path), "\' doesn\'t exist"))) );
				}
				
				global::sys.FileSystem._files.Remove(p);
			}
			;
		}
		
		
		public static void deleteDirectory(string path) {
			string p = global::sys.FileSystem.NormalizePath(path);
			lock(global::sys.FileSystem._lock){
				if ( ! (global::sys.FileSystem._dirs.Contains(p) || global::sys.FileSystem.HasChild(p)) ) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Path \'", path), "\' doesn\'t exist"))) );
				}
				
				string prefix = ( ( p == "/" ) ? ("/") : (global::haxe.lang.Runtime.concat(p, "/")) );
				global::System.Collections.Generic.List<string> fileKeys = new global::System.Collections.Generic.List<string>();
				foreach (string key in global::sys.FileSystem._files.Keys) {
					if (global::StringTools.startsWith(key, prefix)) {
						fileKeys.Add(key);
					}
					
				}
				
				foreach (string key1 in fileKeys) {
					global::sys.FileSystem._files.Remove(key1);
				}
				
				global::System.Collections.Generic.List<string> dirKeys = new global::System.Collections.Generic.List<string>();
				foreach (string key2 in global::sys.FileSystem._dirs) {
					if (( key2 == p ) || global::StringTools.startsWith(key2, prefix)) {
						dirKeys.Add(key2);
					}
					
				}
				
				foreach (string key3 in dirKeys) {
					global::sys.FileSystem._dirs.Remove(key3);
				}
				
			}
			;
		}
		
		
		public static global::Array<string> readDirectory(string path) {
			unchecked {
				if ( ! (global::sys.FileSystem.isDirectory(path)) ) {
					throw ((global::System.Exception) (global::haxe.Exception.thrown(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Path '", path), "' is not a directory"))) );
				}
				
				string p = global::sys.FileSystem.NormalizePath(path);
				string prefix = ( ( p == "/" ) ? ("/") : (global::haxe.lang.Runtime.concat(p, "/")) );
				global::System.Collections.Generic.HashSet<string> names = new global::System.Collections.Generic.HashSet<string>();
				lock(global::sys.FileSystem._lock){
					foreach (string key in global::sys.FileSystem._files.Keys) {
						if (global::StringTools.startsWith(key, prefix)) {
							string rest = global::haxe.lang.StringExt.substr(key, prefix.Length, default(global::haxe.lang.Null<int>));
							int idx = global::haxe.lang.StringExt.indexOf(rest, "/", default(global::haxe.lang.Null<int>));
							string name = (( idx == -1 ) ? (rest) : (global::haxe.lang.StringExt.substr(rest, 0, new global::haxe.lang.Null<int>(idx, true))) );
							if (( name != "" )) {
								names.Add(name);
							}
							
						}
						
					}
					
					foreach (string key1 in global::sys.FileSystem._dirs) {
						if (global::StringTools.startsWith(key1, prefix)) {
							string rest1 = global::haxe.lang.StringExt.substr(key1, prefix.Length, default(global::haxe.lang.Null<int>));
							int idx1 = global::haxe.lang.StringExt.indexOf(rest1, "/", default(global::haxe.lang.Null<int>));
							string name1 = (( idx1 == -1 ) ? (rest1) : (global::haxe.lang.StringExt.substr(rest1, 0, new global::haxe.lang.Null<int>(idx1, true))) );
							if (( name1 != "" )) {
								names.Add(name1);
							}
							
						}
						
					}
					
				}
				;
				global::Array<string> result = new global::Array<string>(new string[]{});
				foreach (string name2 in names) {
					result.push(name2);
				}
				
				return result;
			}
		}
		
		
	}
}
