// Generated by Haxe 4.3.7

#pragma warning disable 109, 114, 219, 429, 168, 162
public class Std {
	
	public Std() {
	}
	
	
	public static bool @is(object v, object t) {
		return global::Std.isOfType(v, t);
	}
	
	
	public static bool isOfType(object v, object t) {
		if (( v == null )) {
			return false;
		}
		
		if (( t == null )) {
			return false;
		}
		
		global::System.Type clt = ( t as global::System.Type );
		if (global::haxe.lang.Runtime.typeEq(clt, null)) {
			return false;
		}
		
		switch (clt.ToString()) {
			case "System.Boolean":
			{
				return v is bool;
			}
			
			
			case "System.Double":
			{
				return v is double || v is int;
			}
			
			
			case "System.Int32":
			{
				return global::haxe.lang.Runtime.isInt(v);
			}
			
			
			case "System.Object":
			{
				return true;
			}
			
			
		}
		
		global::System.Type vt = global::cs.Lib.getNativeType(v);
		if (clt.IsAssignableFrom(((global::System.Type) (vt) ))) {
			return true;
		}
		
		{
			global::cs._NativeArray.NativeArrayIterator<object> _g = new global::cs._NativeArray.NativeArrayIterator<object>(((object[]) (clt.GetInterfaces()) ));
			while (_g.hasNext()) {
				global::System.Type iface = ((global::System.Type) (_g.next()) );
				global::haxe.lang.GenericInterface g = global::haxe.lang.Runtime.getGenericAttr(iface);
				if (( ( g != null ) && global::haxe.lang.Runtime.typeEq(g.generic, clt) )) {
					return iface.IsAssignableFrom(((global::System.Type) (vt) ));
				}
				
			}
			
		}
		
		return false;
	}
	
	
	public static string @string(object s) {
		if (( s == null )) {
			return "null";
		}
		
		if (( s is bool )) {
			if (global::haxe.lang.Runtime.toBool(s)) {
				return "true";
			}
			else {
				return "false";
			}
			
		}
		
		return s.ToString();
	}
	
	
	public static int @int(double x) {
		return ((int) (x) );
	}
	
	
	public static bool isSpaceChar(int code) {
		unchecked {
			if ( ! ((( ( code > 8 ) && ( code < 14 ) ))) ) {
				return ( code == 32 );
			}
			else {
				return true;
			}
			
		}
	}
	
	
	public static bool isHexPrefix(int cur, int next) {
		unchecked {
			if (( cur == 48 )) {
				if (( next != 120 )) {
					return ( next == 88 );
				}
				else {
					return true;
				}
				
			}
			else {
				return false;
			}
			
		}
	}
	
	
	public static bool isDecimalDigit(int code) {
		unchecked {
			if (( 48 <= code )) {
				return ( code <= 57 );
			}
			else {
				return false;
			}
			
		}
	}
	
	
	public static bool isHexadecimalDigit(int code) {
		unchecked {
			if ( ! ((( global::Std.isDecimalDigit(code) || ( ( 97 <= code ) && ( code <= 102 ) ) ))) ) {
				if (( 65 <= code )) {
					return ( code <= 70 );
				}
				else {
					return false;
				}
				
			}
			else {
				return true;
			}
			
		}
	}
	
	
	public static global::haxe.lang.Null<int> parseInt(string x) {
		unchecked {
			if (( x == null )) {
				return default(global::haxe.lang.Null<int>);
			}
			
			int len = x.Length;
			int index = 0;
			while (( index < len )) {
				if ( ! (global::Std.isSpaceChar(global::StringTools.unsafeCodeAt(x, index))) ) {
					break;
				}
				
				 ++ index;
			}
			
			bool isNegative = default(bool);
			if (( index < len )) {
				int sign = global::StringTools.unsafeCodeAt(x, index);
				if (( ( sign == 45 ) || ( sign == 43 ) )) {
					 ++ index;
				}
				
				isNegative = ( sign == 45 );
			}
			else {
				isNegative = false;
			}
			
			bool isHexadecimal = ( ( ( index + 1 ) < len ) && global::Std.isHexPrefix(global::StringTools.unsafeCodeAt(x, index), global::StringTools.unsafeCodeAt(x, ( index + 1 ))) );
			if (isHexadecimal) {
				index += 2;
			}
			
			int cur = index;
			if (isHexadecimal) {
				while (( cur < len )) {
					if ( ! (global::Std.isHexadecimalDigit(global::StringTools.unsafeCodeAt(x, cur))) ) {
						break;
					}
					
					 ++ cur;
				}
				
			}
			else {
				while (( cur < len )) {
					if ( ! (global::Std.isDecimalDigit(global::StringTools.unsafeCodeAt(x, cur))) ) {
						break;
					}
					
					 ++ cur;
				}
				
			}
			
			int firstInvalidIndex = cur;
			if (( index == firstInvalidIndex )) {
				return default(global::haxe.lang.Null<int>);
			}
			
			int result = global::System.Convert.ToInt32(((string) (global::haxe.lang.StringExt.substring(x, index, new global::haxe.lang.Null<int>(firstInvalidIndex, true))) ), ((int) (( (isHexadecimal) ? (16) : (10) )) ));
			if (isNegative) {
				return new global::haxe.lang.Null<int>( - (result) , true);
			}
			else {
				return new global::haxe.lang.Null<int>(result, true);
			}
			
		}
	}
	
	
	public static double parseFloat(string x) {
		unchecked {
			if (( x == null )) {
				return global::Math.NaN;
			}
			
			x = global::StringTools.ltrim(x);
			bool found = false;
			bool hasDot = false;
			bool hasSign = false;
			bool hasE = false;
			bool hasESign = false;
			bool hasEData = false;
			int i = -1;
			while ((  ++ i < x.Length )) {
				int chr = ((int) (x[i]) );
				if (( ( chr >= 48 ) && ( chr <= 57 ) )) {
					if (hasE) {
						hasEData = true;
					}
					
					found = true;
				}
				else {
					switch (chr) {
						case 43:
						case 45:
						{
							if ((  ! (found)  &&  ! (hasSign)  )) {
								hasSign = true;
							}
							else if (( ( ( found &&  ! (hasESign)  ) && hasE ) &&  ! (hasEData)  )) {
								hasESign = true;
							}
							else {
								goto label1;
							}
							
							break;
						}
						
						
						case 46:
						{
							if ( ! (hasDot) ) {
								hasDot = true;
							}
							else {
								goto label1;
							}
							
							break;
						}
						
						
						case 69:
						case 101:
						{
							if ( ! (hasE) ) {
								hasE = true;
							}
							else {
								goto label1;
							}
							
							break;
						}
						
						
						default:
						{
							goto label1;
						}
						
					}
					
				}
				
			}
			label1: {};
			if (( hasE &&  ! (hasEData)  )) {
				 -- i;
				if (hasESign) {
					 -- i;
				}
				
			}
			
			if (( i != x.Length )) {
				x = global::haxe.lang.StringExt.substr(x, 0, new global::haxe.lang.Null<int>(i, true));
			}
			
			try {
				return global::System.Double.Parse(((string) (x) ), ((global::System.IFormatProvider) (global::System.Globalization.CultureInfo.InvariantCulture) ));
			}
			catch (global::System.Exception _g){
				global::haxe.NativeStackTrace.saveStack(_g);
				return global::Math.NaN;
			}
			
			
		}
	}
	
	
	public static int random(int x) {
		if (( x <= 0 )) {
			return 0;
		}
		
		return global::Math.rand.Next(((int) (x) ));
	}
	
	
}


